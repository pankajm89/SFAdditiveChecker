using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace FunctionAdditiveChecker
{
    public class SievePrimeGenerator : IPrimeNumberGenerator
    {
        private int _limit;
        private int _numberOfSegmentsToBeProcessed = 1;
        private ManualResetEvent resetEvent = new ManualResetEvent(false);
        public List<int> result = new List<int>();
        
        public int Limit { get { return _limit; } }

        public SievePrimeGenerator(int limit)
        {
            this._limit = limit;
        }

        /* Function generates prime numbers < limit */
        private List<int> SieveOfErastosthenes(int limit)
        {
            Dictionary<int, bool> numberDict = new Dictionary<int, bool>();

            for (int ctr = 1; ctr < limit; ctr++)
                numberDict.Add(ctr, true);

            numberDict[1] = false;
            for (int i = 2; i < limit; i++)
            {
                if (numberDict[i])
                {
                    for (int j = i * i; j < limit; j += i)
                    {
                        numberDict[j] = false;
                    }
                }
            }
            return numberDict.Where(w => w.Value == true).Select(s => s.Key).ToList();
        }

        public List<int> GeneratePrimeNumbers()
        {
            if (Limit == 0 || Limit == -1 || Limit == 1)
                return new List<int>();

            if (Limit == 2)
            {
                result.Add(2);
                return result;
            }

            string filePath =  Directory.GetCurrentDirectory() + "\\temp.txt";
            List<int> primes = new List<int>();
            
            /*Calculate the length of segments*/
            int segmentLimit = (int)Math.Floor(Math.Sqrt(_limit)) + 1;

            /* Call SieveOfErastosthenes to calculate prime numbers from 1 to Sqrt(n) */
            primes = SieveOfErastosthenes(segmentLimit);
            result.AddRange(primes);
            
            GC.Collect();

            /*Calculate first segment start and end values*/
            long startIndex = segmentLimit;
            long endIndex = 2 * segmentLimit;

            if (endIndex > Limit) endIndex = Limit;

            if (File.Exists(filePath))
                File.Delete(filePath);

            /*Create stream to write to a file*/
            StreamWriter writer = new StreamWriter(new FileStream(filePath, FileMode.OpenOrCreate, FileAccess.Write));
            writer.WriteLine(startIndex + "," + endIndex);

            /*Calulate segments and write startIndex & endIndex to file*/
            while (startIndex < _limit)
            {
                startIndex = startIndex + segmentLimit;
                if (startIndex > Limit) break;

                endIndex = endIndex + segmentLimit;
                if (endIndex >= Limit) endIndex = _limit;

                /*Write startIndex and endIndex to file*/
                writer.WriteLine(startIndex + "," + endIndex);

                _numberOfSegmentsToBeProcessed++; //Global variable used by threads later on.
            }
            writer.Close();

            /*Create stream to read from file*/
            StreamReader reader = new StreamReader(new FileStream(filePath, FileMode.Open, FileAccess.Read));
            string lineFromFile = string.Empty;

            ThreadPool.SetMaxThreads(5, 0);

            /*Create worker threads*/
            while ((lineFromFile = reader.ReadLine()) != null)
            {
                string[] lowHighPair = lineFromFile.Split(',');
                ThreadPool.QueueUserWorkItem(CrossMultiplesOfPrimesInGivenRange, new object[] { lowHighPair[0], lowHighPair[1], primes });
            }
            reader.Close();

            resetEvent.WaitOne(); //wait for all segments to be processed.
            result.Sort();

            return result;
        }

        private void CrossMultiplesOfPrimesInGivenRange(object state)
        {
            try
            {
                object[] inputObj = state as object[];
                int startIndex = Convert.ToInt32(inputObj[0]);
                int endIndex = Convert.ToInt32(inputObj[1]);
                List<int> primes = (List<int>)inputObj[2];

                Dictionary<int, bool> tempPrimeDict = new Dictionary<int, bool>(endIndex - startIndex);
                for (int ctr = startIndex; ctr < endIndex; ctr++)
                    tempPrimeDict.Add(ctr, true);

                /* For each prime number generated by simple sieve, find and cross out all of its multiples 
                   in the remainder of the list*/
                for (int i = 0; i < primes.Count; i++)
                {
                    /*Find the first number in [start..end] that is a multiple of primes[i]*/
                    long minimumDivisibleNumber = (long)Math.Floor((double)startIndex / primes[i]) * primes[i];
                    if (minimumDivisibleNumber < startIndex)
                        minimumDivisibleNumber += primes[i];

                    /*Cross out all multiples of primes[i] in [start..end]*/
                    for (long j = minimumDivisibleNumber; j < endIndex; j += primes[i])
                    {
                        tempPrimeDict[(int)j] = false;
                    }
                }
                
                lock(this)
                {
                    result.AddRange(tempPrimeDict.Where(w => w.Value == true).Select(s => s.Key).ToList());
                }

                tempPrimeDict = null;
            }
            finally
            {
                GC.Collect(); //Free resources used by thread.
                if (Interlocked.Decrement(ref _numberOfSegmentsToBeProcessed) == 0)
                {
                    resetEvent.Set();
                }
            }
        }
    }
}
